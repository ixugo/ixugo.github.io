---
title: 感知机
description: 
date: 2025-08-24
slug: 
image: 
draft: true
categories:
    - Python
tags:
    - Python
---

## 感知机原理

感知机(perceptron) 在 1957 年提出，是作为深度学习的起源算法，学习感知机的构造也就是学习通过神经网络和深度学习的一种重要思想。

perception 接收多个输入信号，输出一个信号。

O 称为神经元或节点，输入信号送往神经元，神经元计算传送信号的总和，当总和超过某个界限值，输出 1，称为「神经元被激活」，这个界限称为阈值，用符号 θ 表示。

![image-20251117234013303](http://img.golang.space/img-1763394013459.png)

perception 的运行原理，用数学表达:

![image-20251117234308961](http://img.golang.space/img-1763394189095.png)

简单的逻辑 and，`(w1, w2,  θ) = (0.5, 0.5, 0.7)`

`1*0.5 + 1*0.5 > 0.7   =>  true` 

```python
1 AND 1  == 1
0 AND 1  == 0
1 AND 0  == 0
0 AND 0  == 0
```

NAND ，将参数值符号取反即可实现， `(w1, w2,  θ) = (-0.5, -0.5, -0.7)`

`1*-0.5 + 1*-0.5 < -0.7  => false`

```python
!(1 AND 1) == 0
!(0 AND 1) == 1
!(1 AND 0) == 1
!(0 AND 0) == 1
```

OR， `(w1, w2,  θ) = (1, 1, 0.7)`

`1 * 1 + 1*0 > 0.7   =>   true`

```python
0 OR 0 == 0
1 OR 1 == 1
1 OR 0 == 1
0 oR 1 == 1
```

将公式中的  θ  换成 -b，于是就得到:

![image-20251118000858806](http://img.golang.space/img-1763395738979.png)

b 称为偏置， w 称为权重，python 代码实现 AND,OR,NAND 的效果如下:

```python
import numpy as np


def AND(x1: int, x2: int) -> int:
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    if np.sum(x * w) + b > 0:
        return 1
    return 0


def OR(x1: int, x2: int) -> int:
    x = np.array([x1, x2])
    w = np.array([1, 1])
    b = -0.7
    if np.sum(x * w) + b > 0:
        return 1
    return 0


def NAND(x1: int, x2: int) -> int:
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])
    b = 0.7
    if np.sum(x * w) + b > 0:
        return 1
    return 0


print(AND(0, 0), False and False)
print(AND(0, 1), False and True)
print(AND(1, 0), True and False)
print(AND(1, 1), True and True)

print(OR(0, 0), False or False)
print(OR(0, 1), False or True)
print(OR(1, 0), True or False)
print(OR(1, 1), True or True)

print(NAND(0, 0), False and False)
print(NAND(0, 1), False and True)
print(NAND(1, 0), True and False)
print(NAND(1, 1), True and True)
```

## 异或门，感知机的局限性

```python
x1 != x2  =>  true
x1 == x2  =>  false
```

感知机无法实现异或门，在数轴上画出 4 个坐标点，没有办法用一条直线分割出 "0" 和 "1" 的空间，曲线可以做到。

由直线分割而成的空间称为线性空间，曲线分割而成的空间称为非线性空间。

![image-20251118004951690](http://img.golang.space/img-1763398191904.png)

## 多层感知机

感知机的绝妙之处在于可以叠加层，通过叠加层来表示异或门。

![image-20251118092155710](http://img.golang.space/img-1763428916040.png)

```python
def XOR(x1: int, x2: int) -> int:
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    return AND(s1, s2)
```

异或门是一种多层结构的神经网络，最左侧一列称为第 0 层，中间一列称为第 1 层，最右侧称为第 2 层。

![image-20251118092446466](http://img.golang.space/img-1763429086626.png)

异或门的感知机总共由 3 层构成，拥有权重的层实质只有 2 层，所以称为 "2 层感知机"。

1. 第 0 层两个神经元接收输入信号，并将信号发送至第 1 层的神经元
2. 第 1 层神经元将信号发送至第 2 层，并输出 y

感知机可以通过叠加层进行非线性的表示。

## 神经网络

用图来表示神经网络的话，最左侧一列称为输入层，最右侧的一列称为输出层，中间的一列称为中间层。中间层也称为隐藏层。

还记得在上文公式中的 b 吗? b 被称为偏执的参数，用于控制神经元被激活的容易程度，而 w1 和 w2 是表示各个信号的权重的参数，用于控制各个信号的重要性。

现在将公式改写为更加简洁的形式。用一个函数来表示这种分情况的动作(超过 0 则输出 1，否则输出 0)。引入 h(x)  阶跃函数。( 阶跃函数以 0 为界，输出从 0 切换到 1 或相反，它的值呈阶梯式变化，所以称为阶跃函数 )

![image-20251225090913980](http://img.golang.space/img-1766624954243.png)

`y = h(b+w1x1 + w2x2)`

![image-20251208092720405](http://img.golang.space/img-1765157240613.png)

h(x) 函数会将输入信号的总和转换为输出信号，这种函数一般称为激活函数。

神经网络中经常使用的一个激活函数就是 sigmoid 函数。

![image-20251209092429786](http://img.golang.space/img-1765243470027.png)

`exp(-x)` 表示 `e^-x` ，e 是 2.7182...

神经网络中用 sigmoid 函数作为激活函数，进行信号的转换，转换后的信号被传送给下一个神经元。感知机和神经网络的主要区别就在于这个激活函数。

![image-20251225091105870](http://img.golang.space/img-1766625066046.png)

sigmoid 函数是一条平滑的曲线，返回的是实数 0.731,0.888.....，即感知机中神经元之间流动的是 0 或 1 的二元信号，神经网络中流动的是实数值信号。

**共同点**

+ 输入信号为重要信息，两个函数都会输出较大的值
+ 输入信号为不重要的信息，两者都输出较小的值
+ 不管输入信号的大小，输出信号的值都在 0~1 之间

**名词**

+ 线性函数是一条笔直的直线
+ 非线性函数，则与线性函数相反
