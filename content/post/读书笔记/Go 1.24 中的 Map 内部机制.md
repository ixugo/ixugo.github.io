---
title: Go 1.24 的 map 更快
description: 
date: 2025-02-18
slug: 
image: 
draft: true
categories:
    - Go
    - 翻译
tags:
    - 读书笔记
---

Go 1.24 中的 Map 经过了彻底重写，性能得到了显著提升。新的实现灵感源自 Google 的高性能哈希表设计——Swiss [Tables](https://abseil.io/about/design/swisstables#swiss-tables-design-notes) 。

在新的实现下，Map 是由 8 个键/值对组成的集合。每个**组**包含 8 个数据槽位，以及一个用于保存**控制字的**元数据字段。控制字大小为 64 位，每个字节代表一个数据槽位。

```
+---------------------+
|  Control Word (64b) |  <- 8 bytes (1 byte per slot)
+---------------------+
|  Key 0  |  Value 0  |  
|  Key 1  |  Value 1  |  
|  Key 2  |  Value 2  |  
|  Key 3  |  Value 3  |  
|  Key 4  |  Value 4  |  
|  Key 5  |  Value 5  |  
|  Key 6  |  Value 6  |  
|  Key 7  |  Value 7  |  
+---------------------+
```

这些组分布在多个表中，每个**表**包含的组数始终是 2 的幂。2 的幂是可以写成 (2^n) 的数字，例如 1、2、4、8 等等……

```
+---------------------+
|       Table 0       |  
+---------------------+
+---------------------+
|  Control Word (64b) |  <- Group 0
+---------------------+
|  Key 0  |  Value 0  |   
...
|  Key 7  |  Value 7  |  
+---------------------+
+---------------------+
|  Control Word (64b) |  <- Group 1
+---------------------+
|  Key 0  |  Value 0  |  
...
|  Key 7  |  Value 7  |  
+---------------------+
```

该 map 保存着指向其管理的表数组的指针，当表的数量发生变化时，用另一个数组替换该数组。

## Key 哈希

当你查找、插入/更新一个键时，会使用哈希函数生成一个 64 位的哈希码。该哈希码会被分为两部分：

1. 前 57 位：称为 `h1` 。
2. 最后 7 位：称为 `h2` 。

完整的哈希码用于确定多表映射中哪个表存储了给定的键。在每个表中，哈希码的 h1 部分标识了可能包含该键的潜在组。一旦选定了组，控制字中的 h2 部分将用于在该组内快速查找键。

键的哈希码用于确定该键属于哪个表。此选择过程根据可用的表数量，使用哈希码的一部分（具体来说是若干位）来完成。例如，如果只有一个表，则不考虑哈希码，所有键都直接归属于该表。如果有两个表，则使用哈希码中的第一位来确定该键属于哪个表：

```
Hash:     : 101010110110
First bit : 1
Table     : 1
```

```
Hash:     : 001010110110
First bit : 0
Table     : 0
```

假设有 4 个表。在这种情况下，使用两位：

```
Hash:        : 101010110110
First 2 bits : 10
Table        : 2
```

```
Hash:        : 001010110110
First 2 bits : 00
Table        : 0
```

```
Hash:        : 011010110110
First 2 bits : 01
Table        : 1
```

### Group 选择

使用哈希值 ( `h1` ) 的前 57 位，内部函数会计算应存储密钥的组的索引。如果该组已满（即所有 8 个槽位均已占用），则使用二次探测来查找下一个要检查的组。二次探测不是像线性探测那样简单地逐个检查组，而是使用数学公式来确定下一个组，步长会随着组数量的增加而增大。这确保了密钥分布在尽可能多的组中，从而减少拥塞并加快查找速度。

如果改用线性探测，运行时每次遇到一个已满的组时，就会直接检查下一个组。例如：

```
Try group 2 => (full).
Try group 3 => (also full).
Try group 4 => (available slot).
```

这可能会导致表开头的组出现拥塞，并且查找会变得更慢，因为运行时必须检查越来越多的组才能找到所需的键。

相比之下，二次探测的探测步骤会在整个表中分散开来，从而减少拥塞并加快查找速度。即使组已满，该公式也能保证下一次探测距离更远，从而更均匀地分布键。

如前所述，控制字大小为 64 位，每个字节代表一个槽位。哈希值 ( `h2` ) 的后 7 位用于填充代表槽位的字节的后 7 位。额外的一位用于将槽位标记为空、已删除或已占用。

```
Empty   : 10000000
Deleted : 11111110
Occupied: 0******* (where * is a bit of h2)
```

在组中查找键时，会扫描控制字，以查找控制字节与键的 h2 匹配的潜在槽位。找到槽位后，运行时会将输入键与占用该槽位的键进行比较。如果匹配，则返回该值。如果不匹配，则检查下一个可能的槽位。

在此示例中，h2 值匹配 `1011011` 的已占用槽位在控制字中出现了两次。这意味着有两个槽位可能用于存储密钥：

```
[01011011]01011010[01011011]1111111011111110010101010111011100101001
```

更新密钥时，首先使用控制字来查找该密钥是否已存在于组中。如果该密钥不存在于组中，或不存在于探测序列中的任何其他组中，则使用第一个可用插槽来插入新密钥。

## Key 查找

在 map 中查找键的过程遵循以下步骤：

1. 使用哈希来确定表。
2. 为可能包含密钥的潜在组创建探测序列（使用 h1）。
3. 逐一检查各个组。
4. 扫描组的控制字来找到与 h2 匹配的可能插槽。
5. 检查存储在每个匹配槽中的密钥以验证它与输入密钥匹配。

遍历组时，如果运行时遇到有空槽的组，搜索将立即停止。此优化允许搜索提前返回，而不是继续不必要地探测序列中的所有组，从而改进了查找过程。

为了使其有效工作，重要的是不要将之前保存已删除键的槽位标记为空。而是将其标记为“已删除”。这确保了搜索过程能够区分真正空的槽位和曾经被占用但现在被删除的槽位，从而使查找能够正确进行，而不会错误地提前停止。

此过程中的优化源于以下因素：

1. 运行时只需要扫描大地图中的单个表。
2. 它仅检查该表内的子集。
3. 它首先使用控制字来验证键的存在，而不是单独遍历每个键值对。
4. 如果发现空槽，它会提前返回。

## Key 修改

当将值插入到映射 `m[k] = v` 时，运行时首先尝试使用与键查找相同的探测序列来查找由相同键占用的插槽。

如果运行时在搜索过程中遇到包含空槽的组，则会断定该键在映射中不存在。然后，该空槽将用于存储新的键值对。

如果没有找到空槽，运行时将继续查找第一个标记为“已删除”的槽。此槽可供重复使用，新的键值对将插入到此已删除的槽中，以确保高效利用表的容量。

## Key 删除

从 Map 中删除键时，运行时会使用与键查找相同的探测序列来搜索该键。对于每个组，运行时会使用控制字检查键，然后检查每个匹配槽中存储的实际键。

如果找到了该键，运行时会检查组中是否有空槽。如果是，则将该键标记为空。否则，将其标记为已删除，以避免过早中断查找，如上一节所述。

如果在组内有空槽的情况下未找到该键，则搜索将停止，因为这意味着该键不存在于 map 中。

## 生长

当您创建一个大小 <= 8 的小 Map 时，运行时会创建一个没有表且只有一个组的 Map。在该组内，所有槽位要么为空，要么已被占用（没有槽位被标记为“已删除”）。这是因为小 Map 不使用探测序列进行查找，而是简单地迭代该组的 8 个槽位，直到找到匹配项。

随着 map 规模的扩大，或者您制作了一个大 map，就会引入表概念，通过在多个组上分布键来加快查找速度。

首次创建表时，会为其分配一个容量，使其能够容纳 16 到 1024 个槽位（相当于 2 到 128 个组）。当已占用槽位数量接近表容量的 87% 左右时，表会进行扩容操作，运行时会将当前容量乘以 2。如果新值等于或小于 1024 个槽位，则将表替换为容量为原表容量两倍的新表。但是，如果扩展表会导致其容量超过 1024 个槽位，则表会被拆分为两个独立的表，以便高效管理不断增长的数据。

当一张表被拆分成两张时，map 数据结构中的表数组会被替换为一个更大的数组，该数组的大小始终为 2 的幂次方（1、2、4、8……）。例如，假设一个 map 最初有两个表（表 0 和表 1）。如果需要拆分表 0，则表的总数将增加到三个。但是，为了保持数组的大小为 2 的幂次方，表数组的大小将增加到 4，并且新数组中的多个条目可以指向同一张表：

```
0 => Table 0a (split version of Table 0)
1 => Table 0b (split version of Table 0)
2 => Table 1
3 => Table 1
```

使用键哈希，拆分前映射到表 0 的内容现在可能映射到表 `0a` 或 `0b` 。而增长前映射到表 1 的内容将继续指向表 1（由数组中的索引 2 和 3 表示）。

```math
Before Growth:

Selection bit = 0  -->  [index 0] -->  Table 0
Selection bit = 1  -->  [index 1] -->  Table 1
```

```math
After Growth:

Selection bits = 00  -->  [index 0]  -->  Table 0a
Selection bits = 01  -->  [index 1]  -->  Table 0b
Selection bits = 10  -->  [index 2]  -->  Table 1
Selection bits = 11  -->  [index 3]  -->  Table 1
```

这种技术避免了重新散列整个 map 并允许各个表单独增长。

## 总结

阅读 Go 1.24 版 map 实现的源代码是一次令人着迷的体验。Go 真正让我钦佩的一点是，它的核心功能是用语言本身实现的。这使得我们能够深入探究其内部结构，准确理解幕后运作方式，并向那些塑造了 Go 语言的才华横溢的贡献者学习。

如果您很好奇并且想自己探索源代码，您可以从[这里](https://github.com/golang/go/blob/master/src/internal/runtime/maps/map.go)开始。

## 参考

本文翻译于 [Map internals in Go 1.24](https://themsaid.com/map-internals-go-1-24)
