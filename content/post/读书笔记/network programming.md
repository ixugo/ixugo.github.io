---
title: 网络编程
description: 
date: 2024-03-25
slug: 
image: 
draft: true
categories:
    - Go
tags:
    - 读书笔记

---

### 网络拓扑

网络中节点的组织称为网络拓扑。网络的拓扑可以像两个节点之间的单个连接一样简单，也可以像复杂的节点布局不共享直接连接，但仍然能够交换数据。您的计算机与互联网上的节点之间的连接通常就是这种情况。拓扑类型分为六种基本类别：点对点、菊花链、总线、环型、星型和网状。

在最简单的点对点网络中，两个节点共享一个连接。这种类型的网络连接并不常见，但在两个节点之间需要直接通信时很有用。

![image-20240818113445235](http://img.golang.space/img-1723952085384.png)

一系列点对点连接形成*菊花链*。从节点 C 发往节点 F 的流量必须经过节点 D 和 E。源节点和目标节点之间的中间节点通常称为*“跃点”* 。您不太可能在现代网络中遇到这种拓扑。

![image-20240818122054783](http://img.golang.space/img-1723954854878.png)

*总线*拓扑节点共享公共网络链路。有线总线网络并不常见，但这种类型的拓扑驱动无线网络。有线网络上的节点会看到所有流量，并有选择地忽略或接受它，具体取决于流量是否是针对它们的。

节点H向节点L发送流量时，节点I、J、K和M收到流量但忽略它。只有节点 L 接受数据，因为它是预期的接收者。尽管无线客户端可以看到彼此的流量，但流量通常是加密的。

![image-20240818122226188](http://img.golang.space/img-1723954946287.png)

在某些光纤网络部署中使用的*环形*拓扑是一种闭环，数据在其中单向传输。

节点N可以通过节点O、P和Q发送一条发往节点R的消息。节点O、P和Q会重传该消息，直到消息到达节点R。如果节点P发生故障重新传输消息，它永远不会到达目的地。由于这种设计，最慢的节点可能会限制数据传输的速度。假设流量按顺时针方向传输，并且节点 Q 最慢，则节点 Q 会减慢从节点 O 发送到节点 N 的流量。但是，从节点 N 发送到节点 O 的流量不会受到节点 Q 速度较慢的限制，因为该流量不会经过节点 Q。

![image-20240818122425035](http://img.golang.space/img-1723955065146.png)

在*星形*拓扑中，中心节点与所有其他节点具有单独的点对点连接。您可能会在有线网络中遇到这种网络拓扑。中心节点通常是*网络交换机*，它是一种从源节点接收数据并将数据重新传输到目的节点的设备，就像邮政服务一样。添加节点只需将它们连接到交换机即可。数据只能穿过此拓扑中的单跳。

![image-20240818122509790](http://img.golang.space/img-1723955109893.png)

全连接*网状*网络中的每个节点都与其他每个节点都有直接连接。此拓扑消除了单点故障，因为单个节点的故障不会影响网络上任何其他节点之间的流量。另一方面，成本和复杂性随着节点数量的增加而增加，使得这种拓扑不适用于大规模网络。这是您可能仅在较大的无线网络中遇到的另一种拓扑。

![image-20240818122545115](http://img.golang.space/img-1723955145217.png)

还可以通过组合两个或多个基本拓扑来创建混合网络拓扑。现实世界的网络很少仅由一种网络拓扑组成。相反，您可能会遇到混合拓扑。

![image-20240818122621738](http://img.golang.space/img-1723955181841.png)

混合拓扑旨在通过利用每种拓扑的优点并将每种拓扑的缺点限制到各个网段来提高可靠性、可扩展性和灵活性。

### 宽带与延迟

网络*带宽*是我们在一段时间内可以通过网络连接发送的数据量。

网络*延迟*是对发送网络资源请求和接收响应之间经过的时间的度量。延迟的一个示例是单击网站上的链接和网站呈现结果页面之间发生的延迟。

可以通过多种方式解决最常见的延迟来源。首先，您可以使用内容交付网络 (CDN) 或云基础设施将您的服务定位在用户附近，从而减少用户与您的服务之间的距离和跃点数量。优化请求和响应大小将进一步减少延迟。

### 开放系统互联参考模型

![image-20240818123232863](http://img.golang.space/img-1723955552975.png)

+ 7应用层，应用程序层负责识别主机和检索资源，例如 web 浏览器。
+ 6表示层，当数据在堆栈中向下移动时，表示层为网络层准备数据；当数据在堆栈中向上移动时，表示层将数据呈现给应用层。加密、解密和数据编码是第 6 层功能。
+ 5 会话层，会话层管理网络上节点之间的连接生命周期。它负责建立连接、管理连接超时、协调操作模式以及终止连接。
+ 4 传输层，传输层控制和协调两个节点之间的数据传输，同时保持传输的可靠性。保持传输的可靠性包括纠正错误、控制数据传输速度、对数据进行分块或分段、重新传输丢失的数据以及确认接收到的数据。如果接收方未确认收到数据，该层中的协议通常可能会重新传输数据。
+ 3网络层，负责在节点之间传输数据。网络层是涉及路由、寻址、多播和流量控制的网络管理协议的所在地。
+ 2数据链路层，处理两个直接连接的节点之间的数据传输。例如，数据链路层促进从计算机到交换机以及从交换机到另一计算机的数据传输。该层中的协议识别并尝试纠正物理层上的错误。
+ 1 物理层，将来自网络堆栈的比特转换为适合底层物理介质的电、光或无线电信号，并从物理介质转换回比特。该层控制比特率。比特率是数据速度限制。

在讨论网络传输速率时，一个常见的混淆是使用每秒字节数而不是每秒位数。我们计算每秒可以传输的零和一或*位*的数量。因此，网络传输速率以每秒位数(bit/s)来衡量。在讨论传输的数据量时，我们使用每秒字节数(Byte/s)。

如果您的 ISP 宣传 100Mbps 的下载速率，并不意味着您可以在一秒钟内下载 100MB 的文件。相反，在理想的网络条件下，可能需要接近八秒的时间。可以说，我们可以通过 100Mbps 连接每秒最多传输 12.5MB。(1 byte = 8 bit;   100/8 =12.5)

### 使用数据封装发送流量

当数据沿着堆栈传输时，它被下面的层封装。我们通常将在堆栈中传输的数据称为 payload，您也可能看到它被称为 message body，文献术语称为服务数据单元(SDU)。

例如，传输层封装来自会话层的 payload，而会话层又封装来自表示层的 payload。当 payload 在堆栈中向上移动时，每一层都会从前一个堆栈中剥离标头信息。

TCP 是第 4 层协议，其 payload 也称为**segments**或 **datagrams**。

TCP 接受第 5 层的有效负载，并在将数据段发送到第 3 层之前添加其标头。第 3 层的*互联网协议**(IP)*接收 TCP 数据段并使用标头对其进行封装，以创建第 3 层的有效负载，即*数据包*。第 2 层接受数据包并添加标头和页脚，创建其有效负载，称为*帧*。第 2 层标头将接收者的 IP 地址转换为*媒体访问控制**(MAC)*地址，该地址是分配给节点网络接口的唯一标识符。它的页脚包含一个*帧校验序列**（FCS）* ，这是一个便于错误检测的校验和。第 1 层以位的形式接收第 2 层的有效负载，并将这些位发送到服务器。

服务器的第 1 层接收位，将其转换为帧，然后将帧发送到第 2 层。第 2 层从帧中剥离其标头和页脚，并将数据包传递到第 3 层。反转每层封装的过程继续进行堆栈向上，直到有效负载到达第 7 层。最后，HTTP 服务器从网络堆栈接收客户端的请求。

### TCP/IP 模型

在研究人员开发 OSI 参考模型的同时，美国国防部的国防高级研究计划局也并行开发协议，现在称为 TCP/IP 模型。

![image-20240818132008668](http://img.golang.space/img-1723958408875.png)

TCP/IP 模型将 OSI 的应用程序、表示层和会话层简化为单个应用程序层，主要是因为 TCP/IP 协议经常跨越 OSI 第 5 层到第 7 层的边界。同样，OSI 的数据链路和物理层对应于 TCP/IP 的链路层。 TCP/IP 和 OSI 的传输层和网络层共享一对一的关系。

您会注意到 TCP/IP 应用层包含三个 OSI 层。这是因为 TCP/IP 没有定义特定的表示或会话功能。相反，特定的应用程序协议实现本身关注这些细节。正如您将看到的，某些 TCP/IP 应用层协议很难完全融入 OSI 模型的单个上层，因为它们具有跨越多个 OSI 层的功能。

*传输层协议*处理两个节点之间的数据传输，例如 OSI 的第 4 层。这些协议可以通过确保从源发送的所有数据完全正确地到达目的地来帮助确保*数据完整性*。

我们的大多数网络应用程序都依赖于传输层协议来处理每个段的纠错、流量控制、重传和传输确认。然而，TCP/IP 模型并不要求每个传输层协议都满足其中每个元素。 UDP 就是这样的一个例子。如果您的应用程序需要使用 UDP 来实现最大吞吐量，则您有责任实现某种错误检查或会话管理，因为 UDP 两者都不提供。

*互联网层*负责在源节点和目标节点之间路由来自上层的数据包。

*链路层*对应于 OSI 参考模型的第 1 层和第 2 层，是核心 TCP/IP 协议和物理介质之间的接口。

链路层的*地址解析协议**(ARP)*将节点的 IP 地址转换为其网络接口的 MAC 地址。在将帧传递到物理网络之前，链路层将 MAC 地址嵌入到每个帧的标头中。

## 资源定位和流量路由

**The Internet Protocol**

IP 是一组规则，规定通过网络（特别是互联网）发送的数据的格式。 *IP 地址*在 TCP/IP 堆栈的互联网层标识网络上的节点。

IP 地址的作用与邮政地址相同；节点通过将数据包寻址到目标节点的 IP 地址来将数据包发送到其他节点。正如邮政邮件通常包含回信地址一样，数据包标头也包含原始节点的 IP 地址。某些协议需要成功交付的确认，并且目标节点可以使用源节点的 IP 地址发送交付确认。

公共使用的 IP 地址有两个版本：IPv4 和 IPv6。

**Network and Host ID**

组成 IPv4 地址的 32 位代表两个组成部分：网络 ID 和主机 ID。*网络 ID*通知负责将数据包传送到目的地的网络设备有关传输中的下一个适当的跃点。这些设备称为*路由器*。

一旦数据到达目标网络，路由器就会使用*主机 ID*将数据传送给特定的接收者。

下图为 32 位 IPv4 地址中常见网络 ID 和主机 ID 大小的细分。

![image-20240818190452241](http://img.golang.space/img-1723979092393.png)

IPv4 地址的网络 ID 部分始终从最左边的位开始，其大小由其所属网络的大小决定。其余位指定主机 ID。例如，IPv4地址的前8位代表8位网络中的网络ID，其余24位代表主机ID。

**IPv4 地址细分为子网**

IPv4 的网络和主机 ID 允许您将超过 40 亿个 IPv4 地址*细分*或分区为更小的组，以保持网络安全且更易于管理。这些较小网络（称为*子网*）中的所有 IP 地址共享相同的网络 ID，但具有唯一的主机 ID。网络的大小决定了主机 ID 的数量，从而决定了网络中单个 IP 地址的数量。

识别各个网络使您可以控制网络之间的信息流。例如，您可以将网络分为一个用于公共服务的子网和另一个用于私有服务的子网。然后，您可以允许外部流量到达您的公共服务，同时阻止外部流量到达您的专用网络。

**使用 CIDR 分配网络**

您可以使用称为*无类别域间路由**(CIDR)*的方法来分配网络。在 CIDR 中，您可以通过向每个 IP 地址附加*网络前缀*（由正斜杠和整数组成）来指示网络 ID 中的位数。

例如 IP 地址 192.168.156.97 用 CIDR 表示法写为 192.168.156.97/16，表明它属于 16 位网络，并且网络 ID 是该地址的前 16 位。

可以通过应用子网掩码派生网络 IP 地址。子网掩码以十进制表示形式对 CIDR 网络前缀进行编码。使用按位 AND 将它们应用于 IP 地址以得出网络 ID。

常见的 CIDR 网络前端，对应的子网掩码。

![image-20240818191115160](http://img.golang.space/img-1723980685432.png)

每行中每个网络的可用主机数量比预期少两个，因为每个网络都有两个特殊地址。网络中的第一个IP地址是网络地址，最后一个IP地址是广播地址。 

以 192.168.0.0/16 为例。网络中的第一个 IP 地址是 192.168.0.0。这是网络地址。网络中的最后一个IP地址是192.168.255.255，这是广播地址。

**分配网络不会在八位字节边界中断**

某些网络前缀不会在八位字节边界处中断。CIDR 表示法中的完整 IP 地址是 192.168.156.97/19。在这种情况下，由于网络前缀不是 8 位的倍数，因此八位字节的位在网络 ID 和主机 ID 之间分开。

![image-20240818194815536](http://img.golang.space/img-1723981695645.png)

**私有地址空间和本地主机**

RFC 1918 详细介绍了在本地网络中使用的私有地址空间 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16。大学、企业、政府和住宅网络可以使用这些子网进行本地寻址。

每个主机都有指定的 127.0.0.0/8 子网作为其本地子网。该子网中的地址是主机的本地地址，简称为*localhost* 。即使您的计算机不在网络上，它仍然应该在 127.0.0.0/8 子网上有一个地址，很可能是 127.0.0.1。

**端口和 socket 地址**

如果您的计算机一次只能通过网络与一个节点进行通信，则不会提供非常高效或愉快的体验。如果您每次单击网络浏览器中的链接时流媒体音乐都会停止，那会变得很烦人，因为浏览器需要中断流以检索请求的网页。值得庆幸的是，TCP 和 UDP 允许我们通过使用*端口*来复用数据传输。

操作系统使用端口来唯一地标识节点之间的数据传输，以便多路复用传出的应用程序数据并将传入的数据解复用回正确的应用程序。 **IP 地址和端口号的组合是*socket 地址*，通常以*IP:Port*格式编写。**

端口是 16 位无符号整数。端口号 0 到 1023 是由*互联网号码分配机构**(IANA)*分配给公共服务的众所周知的端口。 IANA 是一家美国私人非营利组织，负责在全球范围内分配 IP 地址和端口号。例如，HTTP 使用端口 80。端口 443 是 HTTPS 端口。 SSH 服务器通常侦听端口 22。（这些众所周知的端口仅供参考。HTTP 服务器可以侦听任何端口，而不仅仅是端口 80。）

**网络地址解读**

解决 IPv4 短缺的一种方法是使用*网络地址转换 (NAT)* ，该过程允许众多节点共享相同的公共 IPv4 地址。它需要一个设备，例如防火墙、负载平衡器或路由器，可以跟踪传入和传出流量并将传入流量正确路由到正确的节点。

![image-20240818200435360](http://img.golang.space/img-1723982676911.png)

**单播、多播和广播**

将数据包从一个 IP 地址发送到另一个 IP 地址称为*单播寻址*。但 TCP/IP 的互联网层支持 IP*多播*，即向一组节点发送单个消息。您可以将其视为选择加入的邮件列表，例如报纸订阅。

从网络编程的角度来看，多播很简单。路由器和交换机通常会为我们复制消息。

![image-20240818212123311](http://img.golang.space/img-1723987283431.png)

*广播*是同时向网络中的所有 IP 地址传送消息的能力。为此，网络上的节点将数据包发送到子网的*广播地址*。然后，网络交换机或路由器将数据包传播到子网中的所有 IPv4 地址。

![image-20240818212214698](http://img.golang.space/img-1723987334802.png)

**将 MAC 地址解析为物理网络连接**

每个网络接口都有一个唯一标识节点与网络的物理连接的 MAC 地址。 MAC 地址仅与本地网络相关，因此路由器无法使用 MAC 地址跨网络边界路由数据。相反，他们可以使用 IPv4 地址跨网络边界路由流量。一旦数据包到达目标节点的本地网络，路由器就会将数据发送到目标节点的 MAC 地址，最后发送到目标节点的物理网络连接。

*地址解析协议**（ARP）* ， RFC 826 ( https://tools.ietf.org/html/rfc826/ ) 中详细介绍了如何查找给定 IP 地址的适当 MAC 地址，该过程称为*解析*MAC 地址。节点维护将 IPv4 地址映射到 MAC 地址的 ARP 表。如果节点的 ARP 表中没有目标 IPv4 地址的条目，则该节点将向本地网络的广播地址发送请求，询问“谁拥有该 IPv4 地址？请把你的 MAC 地址发给我。哦，这是我的 MAC 地址。”目标节点将接收 ARP 请求并向始发节点发出 ARP 回复。然后，始发节点将数据发送到目标节点的 MAC 地址。网络上参与此对话的节点通常会使用这些值更新其 ARP 表。

**IPv6 寻址**

解决 IPv4 短缺的另一个解决方案是迁移到下一代 IP 寻址 IPv6。 *IPv6 地址*是 128 bit，按冒号分隔的八组 16 位或*十六进制排列。*

*IPv6 十六进制值不区分大小写。但是，互联网工程任务组 (IETF) 建议使用小写值。*

![image-20240818213611094](http://img.golang.space/img-1723988171219.png)

IPv6 地址如下所示：fd00:4700:0010:0000:0000:0000:6814:d103。这比 IPv4 地址更难记住。可以通过遵循一些规则来改进 IPv6 地址的表示方式，使其更具可读性。

可以删除每个十六进制中的所有前导零。这可以简化您的地址而不改变其值。现在看起来像这样：fd00:4700:10:0:0:0:6814:d103。可以用双冒号替换最左边的一组连续的零值十六进制，生成较短的 fd00:4700:10::6814:d103。如果您的地址具有多于一组连续的零值十六进制，您可以仅删除最左边的组。

**IPv6 网络和主机地址**

与 IPv4 地址一样，IPv6 地址也有网络地址和主机地址。 IPv6 的主机地址通常称为*接口 ID* 。网络地址和主机地址均为64位。

网络地址的前 48 位称为*全局路由前缀**(GRP)* ，网络地址的后 16 位称为*子网 ID* 。 48 位 GRP 用于全局细分 IPv6 地址空间并在这些组之间路由流量。子网 ID 用于将每个 GRP 唯一网络进一步细分为特定于站点的网络。如果您运营一家大型 ISP，则会为您分配一个或多个 GRP 唯一的 IPv6 地址块。然后，您可以使用每个网络中的子网 ID 进一步细分为您的客户分配的 IPv6 地址。

![image-20240818214159553](http://img.golang.space/img-1723988519665.png)

IPv6 地址的第一个十六进制为您提供了其使用的线索。以前缀 2000::/3 开头的地址供全球使用，这意味着互联网上的每个节点都将拥有第一个十六进制以 2 或 3 开头的 IPv6 地址。前缀 fc00::/7 指定唯一的本地地址，如 IPv4 中的 127.0.0.0/8 子网。

**IPv6 地址类别**

IPv6 地址分为三类：任播、多播和单播。请注意，与 IPv4 一样，没有广播类型。正如您将看到的，任播和多播地址在 IPv6 中发挥了这一作用。

**Unicast Addresses **

*单播*IPv6 地址唯一标识一个节点。如果发起节点向某个单播地址发送消息，则只有该地址的节点才会收到该消息。

![image-20240818214618268](http://img.golang.space/img-1723988778398.png)

**Multicast Addresses**

*多播*地址代表一组节点。 IPv4 广播地址会将消息传播到网络上的所有地址，而多播地址将同时将消息传递到网络地址的子集（不一定是全部）。多播地址使用前缀 ff00::/8。

![image-20240818223119390](http://img.golang.space/img-1723998190573.png)

**Anycast Addresses **

每个网段的 IPv4 地址必须是唯一的，否则可能会出现网络通信问题。但 IPv6 支持使用相同网络地址的多个节点。*任播*地址表示监听同一地址的一组节点。发送到任播地址的消息将发送到侦听该地址的最近节点。

一组监听同一地址的节点，其中距离发送者最近的节点接收消息。发送者可以发送到虚线代表的任何节点，但发送到最近的节点（实线）

![image-20240818223355704](http://img.golang.space/img-1723998186799.png)

最近的节点并不总是物理上最接近的节点。由路由器决定哪个节点接收消息，通常是节点出发地和目的地之间的延迟最短。除了减少延迟之外，任播寻址还可以增加冗余并可以对服务进行地理定位。

在世界各地发送流量需要花费大量时间，因此您距离服务提供商的服务器越近，您体验到的性能就越好。通过互联网进行地理定位服务是一种常见方法，将服务器放置在靠近用户的地理位置，以确保全球所有用户都能获得最佳性能。在观看 Netflix 流媒体时，您不太可能访问大洋彼岸的服务器。相反，Netflix 会将服务器定位在离您较近的位置，以便您获得理想的体验。

**IPv6 相对于 IPv4 的优势**

除了大得离谱的地址空间之外，IPv6 还比 IPv4 具有固有的优势，特别是在效率、自动配置和安全性方面。

+ **简化的标头格式可实现更高效的路由**， IPv4 标头包含强制但很少使用的字段。 IPv6 使这些字段成为可选字段。
+ **无状态地址自动配置**，管理员手动为网络上的每个节点分配 IPv4 地址，或依靠服务动态分配地址。使用 IPv6 的节点可以通过*无状态地址自动配置**(SLAAC)*自动配置或派生其 IPv6 地址，以减少管理开销。

### The Internet Control Message Protocol

Internet 协议依靠*Internet 控制消息协议**(ICMP)*提供有关本地网络的反馈。 ICMP 可以通知您网络问题、无法访问的节点或网络、本地网络配置、正确的流量路由和网络超时。 IPv4 和 IPv6 都有自己的 ICMP 实现，分别指定为 ICMPv4 和 ICMPv6。

### **名称和地址解析**

*域名系统**(DNS)*是一种将 IP 地址与*域名*相匹配的方法，域名是我们要访问网站时在地址栏中输入的名称。尽管互联网协议使用 IP 地址来定位主机，但域名（如*google.com* ）更容易让人理解和记住。如果我给你访问的 IP 地址 172.217.6.14，你不会知道谁拥有该 IP 地址，也不知道我要引导你访问什么。但如果我给了你*google.com* ，你会确切地知道我要把你发送到哪里。 DNS 允许您记住主机名而不是 IP 地址，就像智能手机的联系人列表使您不必记住所有这些电话号码一样。







## 参考

本文翻译摘录于 network programming with go

Charles M. Kozierok 的*《TCP/IP 指南*》

[HTTP Cache Headers - A Complete Guide](https://www.keycdn.com/blog/http-cache-headers)

