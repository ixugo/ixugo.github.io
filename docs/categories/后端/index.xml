<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>后端 on ixugo</title>
        <link>https://blog.golang.space/categories/%E5%90%8E%E7%AB%AF/</link>
        <description>Recent content in 后端 on ixugo</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 22 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.golang.space/categories/%E5%90%8E%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>太多连接数</title>
        <link>https://blog.golang.space/p/%E5%A4%AA%E5%A4%9A%E8%BF%9E%E6%8E%A5%E6%95%B0/</link>
        <pubDate>Thu, 22 Aug 2024 00:00:00 +0000</pubDate>
        
        <guid>https://blog.golang.space/p/%E5%A4%AA%E5%A4%9A%E8%BF%9E%E6%8E%A5%E6%95%B0/</guid>
        <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;遇到线上服务提示 &lt;code&gt;too many open files&lt;/code&gt;，可以通过 &lt;code&gt;/proc/&amp;lt;进程 ID&amp;gt;/limits&lt;/code&gt; 来查看限制的进程最大连接数，一般是 4096，可以简单的通过修改最大打开文件数量来解决问题，但知其然，更要知其所以然。&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;lsof -p &amp;lt;进程 ID&amp;gt;&lt;/code&gt;  列出以下信息，从下图中可以看到好几千连接数都是这个。&lt;/p&gt;
&lt;p&gt;补充一下图所示分别表示什么意思&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PID: 进程 ID&lt;/li&gt;
&lt;li&gt;USER: 启动进程的用户&lt;/li&gt;
&lt;li&gt;FD: 文件描述符&lt;/li&gt;
&lt;li&gt;TYPE: 文件类型，此处的 sock 表示 套接字。&lt;/li&gt;
&lt;li&gt;DEVICE: 设备号&lt;/li&gt;
&lt;li&gt;SIZE/OFF: 文件大小或偏移量&lt;/li&gt;
&lt;li&gt;NODE: 文件的 iode 节点号码&lt;/li&gt;
&lt;li&gt;NAME: 文件名称或路径/ socket 的详细信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;What Fuck?&lt;/code&gt;，在这里得知了 2 个条件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;90% 的连接数都是同类&lt;/li&gt;
&lt;li&gt;占用竟然全是 TCPv6 的 sock 连接，根据业务判断，不可能同时有这么多连接数，显然是资源泄漏。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://img.golang.space/img-1724294839070.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240822104718879&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt; netstat -anp | grep 16683&lt;/code&gt; 查看连接情况。&lt;/p&gt;
&lt;p&gt;由下图可知没有几千个 tcp6 的链接，但 sock 文件描述符还在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.golang.space/img-1724295757844.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240822110237683&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;基于此，大概问题范围被圈定了，在我们业务中有 2 个地方，会产生这些大量的连接。&lt;/p&gt;
&lt;p&gt;登录网页端，在 2 个业务分别操作，检查占用文件描述符数量是否上涨，最终定位最大嫌疑。&lt;/p&gt;
&lt;p&gt;首先可以确定 socket 是关闭的，所以 ss/netstat 查询不到信息，但文件描述符一直占用，大概率是本地服务还在处理那个关闭的 socket (猜测)，检查对应业务的协程数量是否与文件描述符数量相差无几。&lt;/p&gt;
&lt;h2 id=&#34;验证分析&#34;&gt;验证分析&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>设置 Gitea Actions</title>
        <link>https://blog.golang.space/p/%E8%AE%BE%E7%BD%AE-gitea-actions/</link>
        <pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate>
        
        <guid>https://blog.golang.space/p/%E8%AE%BE%E7%BD%AE-gitea-actions/</guid>
        <description>&lt;h1 id=&#34;gitea-actions&#34;&gt;Gitea Actions&lt;/h1&gt;
&lt;h2 id=&#34;下载文件&#34;&gt;下载文件&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://gitea.com/gitea/act_runner/releases/download/v0.2.10/act_runner-0.2.10-linux-amd64 -O act_runner
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;chmod +x ./act_runner
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./act_runner --version
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gitea.com/gitea/act_runner/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最新版本点这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;注册到-gitea&#34;&gt;注册到 Gitea&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./act_runner register --no-interactive --instance &amp;lt;instance&amp;gt; --token &amp;lt;token&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;instance 就是 Gitea 的访问地址，例如 &lt;code&gt;https://gitea.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;token  可以在 Gitea 实例的 [管理后台]  - [Actions] 获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.golang.space/img-1712991066270.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240413145106002&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;启动&#34;&gt;启动&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./act_runner daemon
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;也可以使用 docker-compose 来启动&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;3.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gitea/act_runner:nightly&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;CONFIG_FILE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/config.yaml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;GITEA_INSTANCE_URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;${INSTANCE_URL}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;GITEA_RUNNER_REGISTRATION_TOKEN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;${REGISTRATION_TOKEN}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;GITEA_RUNNER_NAME&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;${RUNNER_NAME}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;GITEA_RUNNER_LABELS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;${RUNNER_LABELS}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;./config.yaml:/config.yaml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;./data:/data&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/var/run/docker.sock:/var/run/docker.sock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;在存储库设置页面启用-actions&#34;&gt;在存储库设置页面启用 actions&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://img.golang.space/img-1712991453037.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240413145732889&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gitea.com/gitea/act_runner&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;act_runner gitea 仓库&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>证书自动续签方案</title>
        <link>https://blog.golang.space/p/%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE%E6%96%B9%E6%A1%88/</link>
        <pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate>
        
        <guid>https://blog.golang.space/p/%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE%E6%96%B9%E6%A1%88/</guid>
        <description>&lt;h1 id=&#34;证书自动续签方案&#34;&gt;证书自动续签方案&lt;/h1&gt;
&lt;h2 id=&#34;安装-acmesh&#34;&gt;安装 acme.sh&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone --depth &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; https://gitee.com/neilpang/acme.sh.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; acme.sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./acme.sh --install -m my@example.com
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;alias&lt;/span&gt; acme.sh&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;~/.acme.sh/acme.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;my@example.com&lt;/code&gt; 可以指定自己的邮箱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改默认 CA 服务商&lt;/strong&gt;，默认的是 &lt;strong&gt;zerossl&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./acme.sh --set-default-ca --server letsencrypt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;主域名子域名签发证书&#34;&gt;主域名，子域名签发证书&lt;/h2&gt;
&lt;p&gt;可以使用 HTTP/DNSAPI 两种方式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;acme.sh --issue -d example.com -w ./nginx/site/ 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;--issue&lt;/code&gt; 表示要签发证书&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 指定要签发的域名，签发之前要先设计好 DNS 解析到当前主机哦。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-w&lt;/code&gt;  指定网站的根目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--key-file&lt;/code&gt; 指定 key 文件写入哪里&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--fullchain-file&lt;/code&gt; 指定 cer 文件写入哪里&lt;/p&gt;
&lt;h2 id=&#34;泛域名签发证书&#34;&gt;泛域名签发证书&lt;/h2&gt;
&lt;h3 id=&#34;1-设置-dns-api&#34;&gt;1. 设置 DNS API&lt;/h3&gt;
&lt;p&gt;必须使用 DNS API 的方式&lt;/p&gt;
&lt;p&gt;如果是阿里云的证书，可以使用以下方式。(其它&lt;a class=&#34;link&#34; href=&#34;https://github.com/acmesh-official/acme.sh/wiki/dnsapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Ali_Key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;lt;key&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Ali_Secret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;lt;secret&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;2-签发泛域名证书&#34;&gt;2. 签发泛域名证书&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;acme.sh --issue -d example.com -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;*.example.com&amp;#39;&lt;/span&gt; --dns dns_ali
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;将签发的证书安装到指定目录下&#34;&gt;将签发的证书安装到指定目录下&lt;/h2&gt;
&lt;p&gt;程序将会每 60 天重新签发&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;acme.sh --install-cert -d example.com &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--key-file       /path/to/keyfile/in/nginx/key.pem  &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--fullchain-file /path/to/fullchain/nginx/cert.pem &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--reloadcmd     &lt;span class=&#34;s2&#34;&gt;&amp;#34;service nginx force-reload&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;acme.sh --install-cert -d puff.golang.space --key-file       /home/apps/gb/nginx/certs/key.pem  --fullchain-file /home/apps/gb/nginx/certs/cert.pem --reloadcmd     &lt;span class=&#34;s2&#34;&gt;&amp;#34;/home/apps/gb &amp;amp;&amp;amp; docker compose exec -it nginx nginx -s reload&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 升级并保持自动更新&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;acme.sh  --upgrade  --auto-upgrade
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 关闭自动更新&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;acme.sh --upgrade  --auto-upgrade  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;参考&#34;&gt;参考:&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/acmesh-official/acme.sh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/acmesh-official/acme.sh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.orcy.net.cn/1337.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.orcy.net.cn/1337.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developers.weixin.qq.com/community/develop/article/doc/0008ae40ca0af83d0d7e3bb6b56013&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developers.weixin.qq.com/community/develop/article/doc/0008ae40ca0af83d0d7e3bb6b56013&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/2218945?areaSource=102001.10&amp;amp;traceId=XFvJArbxeBBM3HvlN8MOV&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.tencent.com/developer/article/2218945?areaSource=102001.10&amp;traceId=XFvJArbxeBBM3HvlN8MOV&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/387dcb9566f7&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/387dcb9566f7&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>API 设计模式</title>
        <link>https://blog.golang.space/p/api-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate>
        
        <guid>https://blog.golang.space/p/api-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;h1 id=&#34;约定&#34;&gt;约定&lt;/h1&gt;
&lt;p&gt;结构体名 RequestQuery 表示请求的 query 参数，实际业务应该名为 业务名+Input。&lt;/p&gt;
&lt;p&gt;结构体名为 RequestBody 表示请求的 body 参数。&lt;/p&gt;
&lt;p&gt;结构体名为 ResponseBody 表示响应的 body 参数。&lt;/p&gt;
&lt;h2 id=&#34;设计原则&#34;&gt;设计原则&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;名字的寿命可能比项目的生命周期还要长。从变量命名，结构体命名，包名，函数名，到业务名，无处不在，如果变量叫 Channel，业务名叫通道，销售经理叫管道，函数名叫 Pipe，这种割裂感，每位项目参与者真的能明白对方想表达的是什么东西吗?&lt;/p&gt;
&lt;p&gt;代码内的命名还好，一旦是开放的 API ，就不能轻易的更名，所以选择一个清晰简洁通俗易懂的名称，是非常必要的。&lt;/p&gt;
&lt;p&gt;数据请求/响应参数的命名，有大驼峰/小驼峰/蛇形，重点不在于选择哪种方式，而在于统一。看看以下 JSON，你会觉得很享受吗? 每次填写参数的时候，你是否要考虑一下，这个参数是小驼峰还是蛇形来着?&lt;/p&gt;
&lt;p&gt;跟着公司旧项目的命名方式走即可，如果没有旧项目? 可以参考你喜欢的公司用怎样的命名方式，例如看看 ChatGPT ，Twitter(X)，百度等等，选一个作为参考即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;page_number&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;maxPageLimit&amp;#34;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;量词命名应当结尾带上单位，例如开始时间 startAtMs 开始时间戳毫秒，StartAtS 开始时间戳秒。文件大小 sizeBytes，这种明细的单位不用查询文档即可知道其含义。当接口发生变更时(例如更换单位)，新增一个变量名即可，例如 SizeMbypes 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好的 API 应该非常简单的调用，不应该为了一些隐藏或兼容功能，提高调用复杂度。API 不应试图过度减少接口数量，而应该尽可能以最直接的方式公开用户想实现业务的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可预测性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在某些 API 中使用了 page 作为分页，那么在相同查询列表的接口中，也应该使用相同的单词，所有接口使用一致的命名规则能够使 API 的参数可以被预测。如果有些接口中叫 &lt;code&gt;page&lt;/code&gt;，有些接口叫 &lt;code&gt;page_num&lt;/code&gt;，有些接口叫 &lt;code&gt;page_size&lt;/code&gt; ，另外的接口用 &lt;code&gt;pageSize&lt;/code&gt;，调用者会很混乱，同一个东西为什么要起这么多名字? 是有什么特殊性吗?&lt;/p&gt;
&lt;p&gt;个人编写代码可能会出现这种情况，但更多是因为团队开发才出现这种情况，团队开发者如果明确知道这个模型已经定义了，应当先去了解已定义的模型，而不是自己想当然的创建新模型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 以下函数都是为了分页查询消息。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findMessages&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findMessagesByUserID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pageNum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maxSize&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findMessagesByUsername&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pageSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;max_limit&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findInformatiI&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;limit&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// What Fuck?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;富有表现力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接口能够清楚的表达他们想做的事情。例如，将文本转换成另外一种语言，用户可能会频繁的调用接口去判断字符串属于哪个语言? 这属于业务上的需求，如果直接提供一个 &lt;code&gt;detectLanguage&lt;/code&gt; 接口而不是让用户调用大量接口去猜测，情况会好得多。&lt;/p&gt;
&lt;h2 id=&#34;标识符&#34;&gt;标识符&lt;/h2&gt;
&lt;p&gt;通过标识符来区分资源。好的标识符应该有以下优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易于使用，不应该含有特殊符号和保留关键字&lt;/li&gt;
&lt;li&gt;全局唯一&lt;/li&gt;
&lt;li&gt;永久生命周期&lt;/li&gt;
&lt;li&gt;生成快速，简单&lt;/li&gt;
&lt;li&gt;不可预测，可预测的标识符更容易定位和利用潜在的漏洞&lt;/li&gt;
&lt;li&gt;可读，可共享，可验证，应当避免 1，|，L，l，i，I 这些容易混淆，以下字符串中去掉了 容易与 数组 &lt;code&gt;0&lt;/code&gt; 混淆的字母 &lt;code&gt;O&lt;/code&gt;，去掉了容易与数字 &lt;code&gt;1&lt;/code&gt; 混淆的字母&lt;code&gt;I&lt;/code&gt; 和 &lt;code&gt;L&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0123456789ABCDEFGHJKMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在标识符前面应当增加资源，例如设备 &lt;code&gt;/devices/5B82KZMO&lt;/code&gt;，那如果想查询分页设备呢? 一般来说，API 仅当一种资源对另外一种资源拥有所有权时，才应依赖于层次关系。例如分页，分页属于资源的属性，并且经常变动不会持久化存储，不应该存在 &lt;code&gt;/page/1&lt;/code&gt; 或 &lt;code&gt;/devices/5B82KZMO/page/1&lt;/code&gt; 的情况，使用 &lt;code&gt;/devices/5B82KZMO?page=1&lt;/code&gt; 更合理。&lt;/p&gt;
&lt;p&gt;那想查询属于该设备的通道列表呢? 子资源是仅存在于父资源的上下文中的，否则会引出一个问题: 哪个设备的通道呢? 使用 &lt;code&gt;/devices/5B82KZMO/channels&lt;/code&gt; 比较合理。&lt;/p&gt;
&lt;p&gt;有一个较为矛盾的地方，当随着业务发展，可能会出现只想查询通道，并不关心通道属于谁。这时用 &lt;code&gt;/channels&lt;/code&gt; 比较合理，当 &lt;code&gt;device_id&lt;/code&gt; 作为查询条件时，此资源查询已包含 &lt;code&gt;/devices/5B82KZMO/channels&lt;/code&gt; 的相同功能。&lt;/p&gt;
&lt;p&gt;所以，层级划分时，必须明确&lt;strong&gt;子资源是仅存在于父资源的上下文中的&lt;/strong&gt;。分层不宜过深，建议最大 2 层，例如 &lt;code&gt;/users/1/messages/1&lt;/code&gt;，用户和消息两层。当层数过多时，应该考虑是否应该将子资源剥离出来作为顶层资源。&lt;/p&gt;
&lt;h2 id=&#34;请求方法&#34;&gt;请求方法&lt;/h2&gt;
&lt;p&gt;删除资源，正确删除时返回 200，如果资源不存在呢? 有人认为最终结果是正确的所以应该返回 200 结果。有人认为应该区分结果，尝试删除不存在应当返回 404。如果资源存在，尝试访问没有权限的资源怎么办呢? 返回 404 但实际资源是存在，返回 403 无权限但这会被恶意攻击者明确资源存在，可能会被探测并作为攻击目标。&lt;/p&gt;
&lt;p&gt;在设计 API 时，经常会遇到这些选择题，接下来我们将讨论标准 API 应该如何设计，仅供参考，不应该所有实际业务都用标准 API 套用，遇到业务复杂的情况呢? 要灵活。以下内容不是解决问题的金手指，而在于引起一些思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt; (查询资源)&lt;/p&gt;
&lt;p&gt;资源检索，一般通过唯一标识符检索资源，或通过关键信息过滤查找资源。&lt;/p&gt;
&lt;p&gt;此方法应该是幂等的，假设没有发生其它更改的情况，则每次结果都应该相同。&lt;/p&gt;
&lt;p&gt;访问控制，如果某些资源只能被特定用户访问，可以确保资源有单独的父级，例如 &lt;code&gt;/users/:id/messages&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在分布式项目中，计数很难获取精确的结果，提供这种查询容易给使用者误导，应当用估计值而非精确计数;&lt;/p&gt;
&lt;p&gt;假设对分布在 100 个后端的 1 亿数据做排序，这种查询很容易导致服务器过载。这类微小的功能往往会在未来增加大量的复杂性，且对 API 使用者来说价值相对较小。为了实现一个价值相对较小的业务功能，而增加服务的复杂度，代码的维护复杂性，内存倍增，是值得的吗?&lt;/p&gt;
&lt;p&gt;查询部分资源，大多数情况下，查询部分资源只会有 2 个版本，完整数据版和基础数据版。可以通过 query 参数来指定基础版 &lt;code&gt;field=base&lt;/code&gt;，当情况更复杂时，可以指定具体要哪些数据，两种方式应该是二选一实现。&lt;code&gt;fields=name,remark,age&lt;/code&gt;，注意当使用后者时，服务端应当小心的对待这些参数，避免 SQL 注入，或不存在的字段输入了 SQL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt; (创建资源)&lt;/p&gt;
&lt;p&gt;资源创建，请求体包含资源创建信息，并生成对应的资源响应。目标要么是父资源，要么是顶级集合。例如 &lt;code&gt;/users&lt;/code&gt;，&lt;code&gt;/devices&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;资源一旦创建成功，意味着应该允许查询或删除/修改等操作，要保证资源一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Delete&lt;/strong&gt; (删除资源)&lt;/p&gt;
&lt;p&gt;通常使用资源唯一标识符删除，例如 &lt;code&gt;DELETE /users/6n12312m&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;重复删除相同的资源，应当返回正确的结果，无论资源是否存在，其最终达到了删除的目的。可以响应被删除的数据，如果资源不存在时，可能只有资源标识符，资源属性为零值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PATCH&lt;/strong&gt; (部分更新)&lt;/p&gt;
&lt;p&gt;在业务实际使用过程中，并不太需要明确部分更新还是全量更新的区别，建议使用 PUT 替代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PUT&lt;/strong&gt; (替换资源)&lt;/p&gt;
&lt;p&gt;如果使用 PUT 包含 PATCH 的内容，会出现部分更新的状况，此时应该使用 query 参数 fields 来表示哪些参数需要更新，例如 &lt;code&gt;PUT /users/n1i24km?fields=name&lt;/code&gt; ，此时表示只更新用户名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;REST ful API 是将 API 视为资源的设计方案，在实际业务中，有些行为是动作，比如导入导出，比如设备重启/格式化。有些动作并不一定会对资源属性发生更改。这些自定义的方法几乎都应该使用 POST HTTP Method，当然使用其它 Method 也有应用场景，不明确用什么时，那就应该用 POST 。&lt;/p&gt;
&lt;p&gt;为了避免对资源造成混淆，应当避免使用 &lt;code&gt;/&lt;/code&gt; ，可以使用 &lt;code&gt;:&lt;/code&gt; 加动词来指示资源的操作，这可能看起来有点奇怪，但避免歧义很重要。冒号是 URL 中保留特殊字符，会被转码为 &lt;code&gt;%3A&lt;/code&gt; 。例如导出设备通道 &lt;code&gt;/devices/1/channels:export&lt;/code&gt;，导入设备信息 &lt;code&gt;/devices:import&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果对多个不同父级的一组资源操作应该怎么处理呢? 例如 &lt;code&gt;/users/1/messages&lt;/code&gt; 并不关心用户是谁，而关心操作的子资源，此时可以将父标识替换为通配符，如&lt;code&gt;/users/-/messages&lt;/code&gt;，服务端不会去处理父资源，使用通配符从语义上更容易懂。&lt;/p&gt;
&lt;p&gt;通常自定义方法不是幂等的，会有副作用，比如连续 2 次重启设备，第二次执行时设备已经离线了。使用 &lt;code&gt;:&amp;lt;动词&amp;gt;&lt;/code&gt;能够区分标准的资源，应当谨慎的对待这些接口。&lt;/p&gt;
&lt;h2 id=&#34;分页模式&#34;&gt;分页模式&lt;/h2&gt;
&lt;p&gt;大量数据被同时查询，会增加接口耗时，对于用户体验不是很好，每次打开客户端，都要等几秒才能看到结果? 正确使用分页模式，将消息分片，每次返回一部分。&lt;/p&gt;
&lt;p&gt;例如用户的消息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET /users/:id/messages?page=1&amp;amp;size=10&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RequestQuery&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;Page&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// page 用来表示请求的哪一页
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;Size&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// size 表示最大取多少条数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;响应&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;items&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:[],&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;total&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;next&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;items 表示内容列表，total 和 next 一般是二选一存在，当遇到支持跳页时，应该返回 total 表示消息总数，前端可以通过 total 来计算分多少页。 当遇到顺序翻页时( 滚动翻页 )，应当返回 next ，此值是获取下一页的方法。&lt;/p&gt;
&lt;h2 id=&#34;导入导出模式&#34;&gt;导入/导出模式&lt;/h2&gt;
&lt;p&gt;通常导入导出涉及到查询进度，查询状态，历史记录，下载位置等问题。&lt;/p&gt;
&lt;p&gt;以导出用户信息为例:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POST /users/:id/messages:export&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;导入/导出是一个行为动作，所以此处应用 POST 动词加上特殊语法来区分，这不是标准 REST API操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RequestBody&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;nx&#34;&gt;Compression&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 指定文件压缩级别 &amp;lt;=0 不压缩，1-9 压缩级别
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;Filters&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 过滤导出哪些字段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;导入/导出模式应该持续响应进度，可以返回具体的量值，由前端根据需要是计算百分比，还是显示实际的量值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ResponseMetadata&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;Total&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 总任务量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;Current&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 当前执行到第一个任务?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;Success&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 顺利完成任务总量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;Failure&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 操作失败的任务总量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;Err&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 如果当前任务执行失败时存在此信息，否则为 undefined
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最终任务完成时，返回文件信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ResponseBody&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;Path&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 文件地址(如果是本地文件应当返回 path 路径，若是 s3 存储应当返回完整 url 路径)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;Compression&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 压缩信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中导出模式，应当另外提供获取文件的接口。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>分布式事务</title>
        <link>https://blog.golang.space/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
        <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://blog.golang.space/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
        <description>&lt;h1 id=&#34;分布式事务&#34;&gt;分布式事务&lt;/h1&gt;
&lt;p&gt;在一个系统内部，我们可以使用数据库事务来保证数据一致性。&lt;/p&gt;
&lt;p&gt;那如果一笔交易，涉及到跨多个系统、多个数据库的时候，用单一的数据库事务就没办法解决了。&lt;/p&gt;
&lt;p&gt;如何来解决这种跨系统、跨数据库的数据一致性问题呢？答案就是咱们要讨论的主题，分布式事务。&lt;/p&gt;
&lt;p&gt;分布式事务也是事务，也需要遵从 ACID 四个特性，但实际情况是，在分布式系统中，因为必须兼顾性能和高可用，所以是不可能完全满足 ACID 的。我们常用的几种分布式事务的实现方法，都是“残血版”的事务，而且相比数据库事务，更加的“残血”。&lt;/p&gt;
&lt;p&gt;分布式事务的解决方案有很多，比如：2PC、3PC、TCC、Saga 和本地消息表等等。这些方法，它的强项和弱项都不一样，适用的场景也不一样，所以最好这些分布式事务你都能够掌握，这样才能在面临实际问题的时候选择合适的方法。这里面，2PC 和本地消息表这两种分布式事务的解决方案，比较贴近于我们日常开发的业务系统。&lt;/p&gt;
&lt;h2 id=&#34;事务消息&#34;&gt;事务消息&lt;/h2&gt;
&lt;p&gt;在快餐店点餐并付钱后，并不会直接给你餐点，往往是给你一张小票或序号，然后让你拿着凭证到出货区排队取。&lt;/p&gt;
&lt;p&gt;为什么要将付钱和取货两个动作分开呢? 一个很重要的原因是为了使他们接待能力增强。只要凭证能可靠保存，依靠凭证(消息)能完成最终一致性。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分布式事务方法&lt;/th&gt;
&lt;th&gt;强一致性&lt;/th&gt;
&lt;th&gt;高并发&lt;/th&gt;
&lt;th&gt;可用性&lt;/th&gt;
&lt;th&gt;应用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2PC&lt;/td&gt;
&lt;td&gt;优&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;订单系统完成，促销系统销毁优惠券&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;本地消息表&lt;/td&gt;
&lt;td&gt;优&lt;/td&gt;
&lt;td&gt;良&lt;/td&gt;
&lt;td&gt;良&lt;/td&gt;
&lt;td&gt;订单系统完成，购物车系统清空物品&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;事务收件箱--transactional-outbox-&#34;&gt;事务收件箱 ( Transactional outbox )&lt;/h2&gt;
&lt;h2 id=&#34;轮询发布--polling-publisher-&#34;&gt;轮询发布 ( Polling publisher )&lt;/h2&gt;
&lt;h2 id=&#34;-transaction-log-tailing-&#34;&gt;( Transaction log tailing )&lt;/h2&gt;
&lt;h2 id=&#34;两阶段提交--2pc-&#34;&gt;两阶段提交 ( 2PC )&lt;/h2&gt;
&lt;p&gt;mysql的事务就是通过**「日志系统」**来完成两阶段提交的。&lt;strong&gt;由一个全局的事务管理器协调各个子系统的局部事务管理器完成两阶段提交&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在我们购物下单时，如果使用了优惠券，订单系统和优惠券系统都要更新自己的数据，才能完成“在订单中使用优惠券”这个操作。&lt;/p&gt;
&lt;p&gt;订单系统内两个操作的一致性问题可以直接使用数据库事务来解决。促销系统需要操作就比较简单，把刚刚使用的那张优惠券的状态更新成“已使用”就可以了。我们需要这两个系统的数据更新操作保持一致，要么都更新成功，要么都更新失败。&lt;/p&gt;
&lt;p&gt;接下来我们来看 2PC 是怎么解决这个问题的。2PC 引入了一个事务协调者的角色，来协调订单系统和促销系统，协调者对客户端提供一个完整的“使用优惠券下单”的服务，在这个服务的内部，协调者再分别调用订单和促销的相应服务。&lt;/p&gt;
&lt;p&gt;二阶段指的是准备阶段和提交阶段。在准备阶段，协调者分别给订单系统和促销系统发送“准备”命令，订单和促销系统收到准备命令之后，开始执行准备操作。准备阶段都需要做哪些事儿呢？你可以理解为，除了提交数据库事务以外的所有工作，都要在准备阶段完成。比如说订单系统在准备阶段需要完成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在订单库开启一个数据库事务；&lt;/li&gt;
&lt;li&gt;在“订单优惠券表”写入这条订单的优惠券记录；&lt;/li&gt;
&lt;li&gt;在“订单表”中写入订单数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意，到这里我们没有提交订单数据库的事务，最后给事务协调者返回“准备成功”。类似的，促销服务在准备阶段，需要在促销库开启一个数据库事务，更新优惠券状态，但是暂时不要提交这个数据库事务，给协调者返回“准备成功”。协调者在收到两个系统“准备成功”的响应之后，开始进入第二阶段。&lt;/p&gt;
&lt;p&gt;等两个系统都准备好了之后，进入提交阶段。提交阶段就比较简单了，协调者再给这两个系统发送“提交”命令，每个系统提交自己的数据库事务，然后给协调者返回“提交成功”响应，协调者收到所有响应之后，给客户端返回成功响应，整个分布式事务就结束了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.golang.space/shot-1651755392102.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这是正常情况，接下来才是重点：异常情况下怎么办？我们还是分两个阶段来说明。在准备阶段，如果任何一步出现错误或者是超时，协调者就会给两个系统发送“回滚事务”请求。每个系统在收到请求之后，回滚自己的数据库事务，分布式事务执行失败，两个系统的数据库事务都回滚了，相关的所有数据回滚到分布式事务执行之前的状态，就像这个分布式事务没有执行一样。以下是异常情况的时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.golang.space/shot-1651755434095.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在实现 2PC 的时候，没必要单独启动一个事务协调服务，这个协调服务的工作最好和订单服务或者优惠券服务放在同一个进程里面，这样做有两个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参与分布式事务的进程更少，故障点也就更少，稳定性更好；&lt;/li&gt;
&lt;li&gt;减少了一些远程调用，性能也更好一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2PC 是一种强一致的设计，它可以保证原子性和隔离性。只要 2PC 事务完成，订单库和促销库中的数据一定是一致的状态。&lt;/p&gt;
&lt;p&gt;所以 2PC 比较适合那些对数据一致性要求比较高的场景，比如我们这个订单优惠券的场景，如果一致性保证不好，有可能会被黑产利用，一张优惠券反复使用，那样我们的损失就大了。&lt;/p&gt;
&lt;p&gt;2PC 也有很明显的缺陷，整个事务的执行过程需要阻塞服务端的线程和数据库的会话，所以，2PC 在并发场景下的性能不会很高。&lt;/p&gt;
&lt;p&gt;可能出现的问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单点故障&lt;/strong&gt;，一旦事务管理器出现故障，整个系统不可用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据不一致&lt;/strong&gt;，阶段二如果事务管理器只发送&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应时间较长&lt;/strong&gt;，消息链路串行，要等待响应结果，不适合高并发场景&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不确定性&lt;/strong&gt;，当事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;本地消息表&#34;&gt;本地消息表&lt;/h3&gt;
&lt;p&gt;2PC 它的适用场景其实是很窄的，更多的情况下，只要保证数据最终一致就可以了。比如说，在购物流程中，用户在购物车界面选好商品后，点击“去结算”按钮进入订单页面创建一个新订单。这个过程我们的系统其实做了两件事儿。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，订单系统需要创建一个新订单，订单关联的商品就是购物车中选择的那些商品。&lt;/li&gt;
&lt;li&gt;第二，创建订单成功后，购物车系统需要把订单中的这些商品从购物车里删掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也是一个分布式事务问题，创建订单和清空购物车这两个数据更新操作需要保证，要么都成功，要么都失败。但是，清空购物车这个操作，它对一致性要求就没有扣减优惠券那么高，订单创建成功后，晚几秒钟再清空购物车，完全是可以接受的。只要保证经过一个小的延迟时间后，最终订单数据和购物车数据保持一致就可以了。&lt;/p&gt;
&lt;p&gt;本地消息表的实现思路是这样的，订单服务在收到下单请求后，正常使用订单库的事务去更新订单的数据，并且，在执行这个数据库事务过程中，在本地记录一条消息。这个消息就是一个日志，内容就是“清空购物车”这个操作。因为这个日志是记录在本地的，这里面没有分布式的问题，那这就是一个普通的单机事务，那我们就可以让订单库的事务，来保证记录本地消息和订单库的一致性。完成这一步之后，就可以给客户端返回成功响应了。&lt;/p&gt;
&lt;p&gt;然后，我们再用一个异步的服务，去读取刚刚记录的清空购物车的本地消息，调用购物车系统的服务清空购物车。购物车清空之后，把本地消息的状态更新成已完成就可以了。异步清空购物车这个过程中，如果操作失败了，可以通过重试来解决。最终，可以保证订单系统和购物车系统它们的数据是一致的。&lt;/p&gt;
&lt;p&gt;消息队列 RocketMQ 提供一种事务消息的功能，其实就是本地消息表思想的一个实现。使用事务消息可以达到和本地消息表一样的最终一致性，相比我们自己来实现本地消息表，使用起来更加简单，你也可以考虑使用。&lt;/p&gt;
&lt;p&gt;如果看事务的 ACID 四个特性，本地消息表这种方法，它只能满足 D（持久性），A（原子性）C（一致性）、I（隔离性）都比较差，但是，它的优点非常突出。&lt;/p&gt;
&lt;p&gt;首先，实现简单，在单机事务的基础上稍加改造就可以实现分布式事务，另外，本地消息表的性能非常好，和单机事务的性能几乎没有差别。在这个基础上，还提供了大部分情况下都能接受的“数据最终一致性”的保证，所以，本地消息表是更加实用的分布式事务实现方法。&lt;/p&gt;
&lt;p&gt;当然，即使能接受数据最终一致，本地消息表也不是什么场景都可以适用的。它有一个前提条件就是，异步执行的那部分操作，不能有依赖的资源。比如说，我们下单的时候，除了要清空购物车以外，还需要锁定库存。&lt;/p&gt;
&lt;h2 id=&#34;三阶段提交--3pc-&#34;&gt;三阶段提交 ( 3PC )&lt;/h2&gt;
&lt;p&gt;相对于2PC来说增加了CanCommit阶段和超时机制。如果段时间内没有收到协调者的commit请求，那么就会自动进行commit，解决了2PC单点故障的问题。&lt;/p&gt;
&lt;p&gt;但是性能问题和不一致问题仍然没有根本解决。下面我们还是一起看下三阶段流程的是什么样的？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一阶段，协调者询问事务参与者，你是否有能力完成此次事务。
&lt;ol&gt;
&lt;li&gt;都返回 yes，进入第二阶段&lt;/li&gt;
&lt;li&gt;有一个返回 no 或 等待响应超时，则中断事务，并向参与者发送 abort 请求&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第二阶段，协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作，并将Undo和Redo信息记录到事务日志中。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。&lt;/li&gt;
&lt;li&gt;第三阶段，在阶段二中如果所有的参与者节点都可以进行PreCommit提交，那么协调者就会从“预提交状态”转变为“提交状态”。然后向所有的参与者节点发送&amp;quot;doCommit&amp;quot;请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的Ack消息后完成事务。相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>保证接口数据安全的方案</title>
        <link>https://blog.golang.space/p/%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%A1%88/</link>
        <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://blog.golang.space/p/%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%A1%88/</guid>
        <description>&lt;h1 id=&#34;保证接口数据安全的方案&#34;&gt;保证接口数据安全的方案&lt;/h1&gt;
&lt;h2 id=&#34;数据加密防止明文传输&#34;&gt;数据加密，防止明文传输&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;不需要解密，只需要验证是否相同的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如登录时的密码，可以在前端编码成 MD5 传输。MD5具有不可逆的性质，非常适合用来存储这些。&lt;/p&gt;
&lt;p&gt;为了防止数据库泄露暴露 MD5 密码，或者希望更安全，可以对 MD5 加盐。&lt;/p&gt;
&lt;p&gt;比如   MD5( password + salt )，salt 可以是每个用户唯一的，防止如果某个用户的密码被穷举破解出来了，不能使用现有的成果来类推其它用户的密码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要解密，使用原来的参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 AES 对称加密算法，这个需要服务端和客户端都存储秘钥，如果不用暴露客户端，这种方案很合适。&lt;/p&gt;
&lt;p&gt;使用 RSA 非对称加密，会生成私钥和公钥。&lt;/p&gt;
&lt;h2 id=&#34;数据加签验签&#34;&gt;数据加签验签&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;加签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它可以保证数据在传输过程中不被篡改。&lt;/p&gt;
&lt;p&gt;使用 MD5/ShA-256 对原始请求报文生成摘要，使用私钥对摘要加密，就得到了报文对应的数字签名。&lt;/p&gt;
&lt;p&gt;将 报文原文和签名 一起发到接收方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收方对原始数据以相同方法处理，得到摘要，使用对方提供的公钥对数字签名解密，判断两个摘要是否相同。就可以得知报文有没有被篡改过。&lt;/p&gt;
&lt;h2 id=&#34;token-授权认证&#34;&gt;token 授权认证&lt;/h2&gt;
&lt;p&gt;非登录接口如何识别用户的身份?&lt;/p&gt;
&lt;p&gt;可以在用户名密码登录接口中返回唯一 token。请求其它需要权限的接口必须带上此 token，服务端解析 token 验证身份，并检查 token 是否 过期。&lt;/p&gt;
&lt;p&gt;此方式也可用于唯一设备登录，每个用户最后一次登录生成的 token 记录到 redis 缓存中，每次登陆都会覆盖掉旧的。接口请求时，服务端验证其 token 是否与服务端的一致，如果不一致，就提示用户重新登录。&lt;/p&gt;
&lt;p&gt;另外关于身份验证错误的状态码&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考网址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;token 不存在或解析失败，token 过期等返回 401 错误&lt;/p&gt;
&lt;p&gt;token 验证通过，但对资源没有访问的权限，返回 403 错误&lt;/p&gt;
&lt;h2 id=&#34;时间戳-timestamp-超时&#34;&gt;时间戳 timestamp 超时&lt;/h2&gt;
&lt;p&gt;有些攻击者，不关心真实的数据，而是抓包后进行恶意请求，如 DOS 攻击。&lt;/p&gt;
&lt;p&gt;可以引入时间戳 ，来保证接口安全，客户端每次请求都带上当前时间，求服务端时间与请求时间的时间差，大于一定时间如 2 分钟，则认为请求无效。&lt;/p&gt;
&lt;p&gt;只加时间，很容易破解，无非每次请求时更新一下时间，可以在时间戳的基础上，与「数据加签验签」结合。&lt;/p&gt;
&lt;h2 id=&#34;timestampnonce-防止重放攻击&#34;&gt;timestamp+nonce 防止重放攻击&lt;/h2&gt;
&lt;p&gt;nonce 指唯一的随机字符串，在客户端维护一个随机字符串 set，每次请求使用 timestamp+nonce，nonce 不能重复。&lt;/p&gt;
&lt;p&gt;服务端也维护一个相同的 set，如果发现重复的 nonce 就是重复请求。 因为有 timestamp 仅接收 2分钟内的请求，所以服务端和客户端可以都只维护 2分钟内的 nonce ，以节省内存。&lt;/p&gt;
&lt;h2 id=&#34;限流&#34;&gt;限流&lt;/h2&gt;
&lt;p&gt;可以从以下方面考虑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每分钟可以接收多少次请求&lt;/li&gt;
&lt;li&gt;服务端最大能同时处理多少请求&lt;/li&gt;
&lt;li&gt;每个 IP， 1 分钟内最多请求次数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;黑名单&#34;&gt;黑名单&lt;/h2&gt;
&lt;p&gt;对于黑名单的 IP，返回错误码&lt;/p&gt;
&lt;p&gt;建议黑名单加上时间限制，对于明知是恶意的攻击，多长时间都可以&lt;/p&gt;
&lt;p&gt;对于不确定，模棱两可，或只是小小的警告惩罚，可以设定有限的时间。&lt;/p&gt;
&lt;h2 id=&#34;白名单&#34;&gt;白名单&lt;/h2&gt;
&lt;p&gt;仅允许白名单内的 IP 访问&lt;/p&gt;
&lt;h2 id=&#34;参数合法性效验&#34;&gt;参数合法性效验&lt;/h2&gt;
&lt;p&gt;如手机号和身份证检测长度等是否合法。&lt;/p&gt;
&lt;p&gt;枚举参数是否合法。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
